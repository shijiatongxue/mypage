<!DOCTYPE html>
<html lang="ch">
  <head>
    <link rel="icon" href="https://shijiatongxue.github.io/images/sj.png" type="image/png">
    <link rel="shortcut icon" href="https://shijiatongxue.github.io/images/sj.png" type="image/png">
    <link rel="stylesheet" href="https://shijiatongxue.github.io/styles/article.css">
    <title>大数的最大公约数问题</title>
  </head>
  <body>
    <!-- 输入文章类别：JavaScript -->
    <article>
      <h1>大数的最大公约数问题</h1>
      <p class="info">作者：石嘉</p>
      <p class="info">日期：2019年8月4日</p>
      <p class="info">参考：<a href=""></a></p>
      <h2>JavaScript的数值范围</h2>
      <li>最小值：Number.MIN_VALUE = 5e-324</li>
      <li>最大值：Number.MAX_VALUE = 1.7976931348623157e+308</li>
      <li>最大安全整数：Number.MAX_SAFE_INTEGER = [-(2^53-1), 2^53-1]</li>
      <h2>解题思路</h2>
      <pre>
        <code class="language-javascript">
        // 基本的最大公约数，递归
        function gcd(m,n){
            if (m%n === 0){
                return n;
            }
            return gcd(n, m%n);
        }  
        </code>
      </pre>
      <p>对于大数，可以采用这样的思路。如果x和y（x>y）可以被一个最大公约数整除，则x-y和y也可以被相同的数整除，原因如下：</p>
      <pre>
        <code class="language-text">
          x = k * m; 
          y = k * n; 
          x-y = k * (m-n);
        </code>
      </pre>
      <p>所以对于求gcd(60, 20)，等于求gcd(40, 20)=gcd(20, 20)=gcd(20, 0)，所以最大公约数为20。</p>
      <pre>
        <code class="language-javascript">
        // 大数求最大公约数
        function gcd2(x, y){
          if (x < y) {
            [x, y] = [y, x];
          }
          return y===0? x : gcd2(x-y, y)
        }
        </code>
      </pre>
      <p>但是这种方法存在弊端，如果两个数量级差别较大，则调用栈会溢出。</p>
      <h2>继续优化</h2>
      <p>如果递归层数过多的话，可能会溢出，现在进行优化，思路是寻找小数代替大数：</p>
      <p>若x，y均是偶数，则gcd(x, y) = 2 * gcd(x/2, y/2)；</p>
      <p>若x为偶数，y为奇数，则gcd(x, y) = gcd(x/2, y)；</p>
      <p>若x为奇数，y为奇数，则gcd(x, y) = gcd(x-y, y)；</p>
      <pre>
        <code class="language-javascript">
        // 优化算法
        function gcd3(x, y){
          if (x < y){
            [x, y] = [y, x];
          }
          if (y === 0){
            return x;
          }
          if (x%2 === 0){
            if (y%2 == 0){
              return 2 * gcd3(x/2, y/2)
            }
            return gcd3(x/2, y);
          }
          // 若y为偶数，x为奇数
          if (y%2 === 0){
            return gcd3(x, y/2);
          } else{
            return gcd3(x-y, y);
          }
        }
        </code>
      </pre>
      <p>实测效果：</p>
      <pre>
        <code class="language-javascript">
        // 第二种算法无法解决递归调用问题
        gcd2(20, 1000000);
        // Uncaught RangeError: Maximum call stack size exceeded

        // 可以实现大数求公约数
        gcd3(2**53, 800);
        // 32
        </code>
      </pre>
      <h2>测试Chrome的递归调用深度</h2>
      <pre>
        <code class="language-javascript">
        function counter(n){
            while ( n > 0 ) {
                console.log(n);
                return counter(n+1);
            }
        }

        // 12577 报错
        </code>
      </pre>
      <p>（完）</p>
    </article>
    <script src="https://shijiatongxue.github.io/js/prism.js"></script>
  </body>
</html>