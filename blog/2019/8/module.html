<!DOCTYPE html>
<html lang="ch">
  <head>
    <link rel="icon" href="https://shijiatongxue.github.io/images/sj.png" type="image/png">
    <link rel="shortcut icon" href="https://shijiatongxue.github.io/images/sj.png" type="image/png">
    <link rel="stylesheet" href="https://shijiatongxue.github.io/styles/article.css">
    <title>模块简介</title>
  </head>
  <body>
    <!-- 输入文章类别：JavaScript -->
    <article>
      <h1>模块简介</h1>
      <p class="info">作者：石嘉</p>
      <p class="info">日期：2019年8月8日</p>
      <p class="info">参考：<a href="https://zh.javascript.info/modules-intro">JavaScript.Info</a></p>
      <h2>什么是模块？</h2>
      <p>模块仅仅是一个文件，一个脚本而已，它就是这么简单。</p>
      <p>导出</p>
      <pre>
        <code class="language-javascript">
        // sayHi.js
        export function sayHi(user) {
          alert(`Hello, ${user}!`);
        }
        </code>
      </pre>
      <p>导入</p>
      <pre>
        <code class="language-javascript">
        // main.js
        import {sayHi} from './sayHi.js';

        alert(sayHi); // function...
        sayHi('John'); // Hello, John!
        </code>
      </pre>
      <div class="text"></div>
      <p>上面这句话是在浏览器中导入模块，代码如下：</p>
      <pre>
        <code class="language-html">
          &lt;div class=&quot;text&quot;&gt;&lt;/div&gt;
          
          &lt;script type=&quot;module&quot;&gt;
            import {sayHi} from './say.js';

            document.getElementsByClassName('text')[0].innerHTML = sayHi('Shi');
          &lt;/script&gt;
        </code>
      </pre>
      <p>由于模块使用特殊的关键字和功能，所以我们必须通过使用属性&lt;script type=&quot;module&quot;&gt;来告诉浏览器，脚本应该被当做模块来看待。</p>
      <h2>核心模块功能</h2>
      <h3>始终使用"use strict"</h3>
      <p>对一个未声明的变量赋值将会抛出错误。</p>
      <pre>
        <code class="language-javascript">
          a = 5; // error
        </code>
      </pre>
      <h3>模块级作用域</h3>
      <h3>模块代码仅在第一次导入时解析</h3>
      <pre>
        <code class="language-javascript">
        // 从不通过的文件导入相同的模块
        
        // 1.js
        import `./alert.js`; // Module is evaluated!
        
        // 2.js
        import `./alert.js`; // (nothing)
        </code>
      </pre>
      <p>在日常开发中，顶级模块主要是用于初始化使用的。我们创建数据结构，预填充它们，如果我们想要可重用的某些东西，只要导出即可。</p>
      <p>下面是一个高级点的例子：</p>
      <p>我们假设一个模块导出了一个对象：</p>
      <pre>
        <code class="language-javascript">
        // admin.js
        export let admin = {
          name: "John"
        };
        </code>
      </pre>
      <p>如果这个模块被导入到多个文件，模块仅仅在第一次导入的时候解析创建admin对象。然后将其传入所有导入的位置。</p>
      <pre>
        <code class="language-javascript">
          // 1.js
          import {admin} from './admin.js';
          admin.name = "Pete";

          // 2.js
          import {admin} from './admin.js';
          alert(admin.name); // Pete

          // 1.js 和 2.js 导入相同的对象
          // 1.js 中对对象的修改，在 2.js 中是可以访问的
        </code>
      </pre>
      <p>所以，让我们再重申一下：模块只执行一次生成导出，然后在导入的位置共享一个导出，当某个位置修改了admin对象，在其他模块中是可以看到修改的。</p>
      <p>例如，下面的admin.js模块可能提供特定的功能，但是希望在外部可以访问admin对象：</p>
      <pre>
        <code class="language-javascript">
        // admin.js
        export let admin = {};

        export function sayHi() {
          alert(`Ready to serve, ${admin.name}!`);
        }
        </code>
      </pre>
      <p>现在，在init.js——我们app的第一个脚本中，设置了admin.name。现在每个位置都能看到它了，包括来自admin.js本身的调用。</p>
      <pre>
        <code class="language-javascript">
         // init.js
         import {admin} from './admin.js';
         admin.name = "Pete"; 
        </code>
      </pre>
      <pre>
        <code class="language-javascript">
          // other.js
          import {admin, sayHi} from './admin.js';
          
          alert(admin.name); // Pete
          sayHi(); // Ready to serve, Pete!
        </code>
      </pre>
      <h3>顶级"this"是未定义的</h3>
      <p>在一个模块中，顶级this是未定义的，而不是像非模块脚本中的全局变量。</p>
      <pre>
        <code class="language-javascript">
          &lt;script&gt;
            alert(this); // window
          &lt;/script&gt;

          &lt;script type=&quot;module&quot;&gt;
            alert(this); // undefined
          &lt;/script
        </code>
      </pre>
      <h2>特定于浏览器的功能</h2>
      <p>与常规脚本相比，拥有type="module"标识的脚本有几个特定于浏览器的差异。</p>
      <h3>模块脚本是延迟解析的</h3>
      <p>对于外部和内联<em>模块脚本</em>来说，它总是延迟解析的，就和defer属性一样。</p>
      <p>也就是说：</p>
      <li>外部模块脚本不用阻塞HTML的解析，它们与其他资源并行加载。</li>
      <li>直到HTML文档完全解析渲染后，模块脚本才会开始运行。</li>
      <li>执行脚本的相对顺序：在前面的先执行。</li>
      <h3>内联脚本可异步</h3>
      <p>内联脚本和外部脚本都允许使用async属性，当导入的模块被处理时，异步脚本会立即执行，与其他的脚本或者HTML文档无关。</p>
      <p>这对于不依赖任何其他东西的功能来说是很棒的，比如计数器，广告和文档级的事件监听器。</p>
      <h3>外部脚本</h3>
      <p>外部脚本相较于其他脚本有两个显著的差异：</p>
      <ol>
        <li>具有相同src属性值的外部脚本仅运行一次：</li>
        <pre>
          <code class="language-javascript">
            &lt;!-- my.js 脚本被加载，但它只运行一次 --&gt;
            &lt;script type=&quot;module&quot; src=&quot;my.js&quot;&gt;&lt;/script&gt;
            &lt;script type=&quot;module&quot; src=&quot;my.js&quot;&gt;&lt;/script&gt;
          </code>
        </pre>
        <li>从其他域名获取的外部脚本需要加上CORS头。如果一个模块脚本是从其他域名获取的，那么它所在的远端服务器必须提供Access-Control-Allow-Origin: *（可能使用加载的域名代替*）响应头以知名当前请求是被允许的。</li>
        <pre>
          <code class="language-javascript">
          &lt;!-- another-site.com 必须提供 Access-Control-Allow-Origin --&gt;
          &lt;!-- 否则，脚本不会执行 --&gt;
          &lt;script type=&quot;module&quot; src=&quot;http://another-site.com/their.js&quot;&gt;&lt;/script&gt;
          </code>
        </pre>
      </ol>
      <p>这可以保证最基本的安全。</p>
      <h3>不允许裸模块</h3>
      <p>在浏览器中，必须给予import一个相对或者绝对的URL。</p>
      <pre>
        <code class="language-javascript">
        import {sayHi} from 'sayHi'; // Error，&ldquo;裸&rdquo;模块
        // 模块必须提供路径，例如 './sayHi.js'
        </code>
      </pre>
      <h3>兼容性</h3>
      <p>旧时的浏览器不理解type="module"值。对于位置类型的脚本会被忽略掉。对于它们来说可以使用momodule属性来提供后备：</p>
      <pre>
        <code class="language-javascript">
        &lt;script type=&quot;module&quot;&gt;
          alert(&quot;Runs in modern browsers&quot;);
        &lt;/script&gt;

        &lt;script nomodule&gt;
          alert(&quot;Modern browsers know both type=module and nomodule, so skip this&quot;)
          alert(&quot;Old browsers ignore script with unknown type=module, but execute this.&quot;);
        &lt;/script&gt;   
        </code>
      </pre>
      <p>如果我们使用打包工具，当脚本被打包仅一个单一文件（或者几个文件），在这些脚本中，import/export语句被特殊的打包函数处理后替代。因此最终打包好的脚本不包含任何improt/export语句，它也不需要type="module"属性，我们仅像普通脚本一样使用就好了。</p>
      <pre>
        <code class="language-javascript">
          &lt;!-- 假设我们从诸如 Webpack 这类的打包工具中获得了 &quot;bundle.js&quot; 脚本 --&gt;
          &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 
        </code>
      </pre>
      <p>（完）</p>
    </article>
    <script src="https://shijiatongxue.github.io/js/prism.js"></script>
    <script type="module">
        import {sayHi} from './say.js';

        document.getElementsByClassName('text')[0].innerHTML = sayHi('Shi');
      </script>
  </body>
</html>