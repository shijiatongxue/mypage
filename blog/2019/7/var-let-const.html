<!DOCTYPE html>
<html lang="ch">
    <head>
        <link rel="icon" href="https://shijiatongxue.github.io/images/sj.png" type="image/png">
        <link rel="shortcut icon" href="https://shijiatongxue.github.io/images/sj.png" type="image/png">
        <link rel="stylesheet" href="https://shijiatongxue.github.io/styles/article.css">
        <title>var、let与const的实现原理</title>
    </head>
    <body>
        <!-- 输入文章类别： -->
        <article>
            <h1>var、let与const的实现原理</h1>
            <p class="info">作者：石嘉</p>
            <p class="info">日期：2019年7月10日</p>
            <p class="info">参考：ES6标准入门</p>
            <p class="info"><a href="https://zhuanlan.zhihu.com/p/28140450">方应杭</a></p>
            <h2>概述</h2>
            <p>ES6新添加了两种声明变量的方式，let和const。let声明的变量只在块级作用域内有效，const声明的变量声明完必须立即赋值，且不许更改。接下来我们看一下它们的特点和底层的实现细节。</p>
            <h2>let和const</h2>
            <h3>let命令</h3>
            <ul>
                <li>只在代码块内有效，在代码块之外引用会报ReferenceError；</li>
                <li>let声明的变量在for循环中仅本轮有效，每一轮都需要重新声明；</li>
                <li>不存在变量提升，声明的变量必须在声明后使用，否则会报ReferenceError；</li>
                <li>存在暂时性死区；</li>
                <li>不可以重复声明同一个变量；</li>
            </ul>
            注意：函数的参数作用域和函数体作用域是同一个作用域；for循环的声明变量作用域和循环体不是一个作用域，其中，设置循环变量的作用域是循环体内部的父作用域。
            <h3>const命令</h3>
            <ul>
                <li>const只声明不赋值会报错；</li>
                <li>const实际上保证的是变量指向的那个内存地址不得变动；</li>
                <li>const同样存在块级作用域，变量不提升，暂时性死区，不可重复声明。</li>
            </ul>
            <pre>
                <code class="language-javascript">
                    const foo = {};
                    
                    // 为foo添加一个属性，可以成功
                    foo.prop = 123;
                    foo.prop // 123
                    
                    // 将foo指向另一个对象，报错
                    foo = {}; // TypeError
                </code>
            </pre>
            <h3>暂时性死区</h3>
            <p>在代码块内，使用let声明变量之前，该变量都是不可用的。这在语法上称为“暂时性死区”。</p>
            <pre>
                <code class="language-javascript">
                  if(true){
                      // TDZ开始
                      tmp = 'abc'; // ReferenceError
                      console.log(tmp); // ReferenceError

                      // TDZ结束
                      let tmp; // 声明变量
                      console.log(tmp); // undefined

                      tmp = 123;
                      console.log(tmp); // 123
                  }
                </code>
            </pre>
            <h2>具体实现</h2>
            <h3>var声明的创建、初始化和赋值</h3>
            <pre>
                <code class="language-javascript">
                    function fn(){
                        var x = 1
                        var y = 2
                        }
                    fn();
                </code>
            </pre>
            <p>上面函数运行时会有如下步骤：</p>
            <ul>
                <li>进入fn，为fn创建一个环境；</li>
                <li>找到所有var语句，创建变量；</li>
                <li>将这些变量初始化为undefined；</li>
                <li>执行代码；</li>
                <li>变量赋值，x=1，y=2；</li>
            </ul>
            <h3>函数声明的创建、初始化和赋值</h3>
            <pre>
                <code class="language-javascript">
                    fn2()

                    function fn2(){
                        console.log(2)
                    }

                    // 打印结果如下
                    // fn2(){
                    //  console.log(2);
                    // }
                </code>
            </pre>
            <h3>暂时性死区的原理</h3>
            <ul>
                <li>对于let或const声明的变量，未声明之前会把它们放在TDZ，当在对它进行操作时，首先会查找TDZ有没有这个变量，如果有则报错；</li>
                <li>对于var声明的变量，则把它们提升到顶部作用域，访问时返回undefined。</li>
            </ul>
            <p>（完）</p>
        </article>
        <script src="https://shijiatongxue.github.io/js/prism.js"></script>
    </body>
</html>