<!DOCTYPE html>
<html lang="ch">
    <head>
        <link rel="icon" href="https://shijiatongxue.github.io/images/sj.png" type="image/png">
        <link rel="shortcut icon" href="https://shijiatongxue.github.io/images/sj.png" type="image/png">
        <link rel="stylesheet" href="https://shijiatongxue.github.io/styles/article.css">
        <title>聊聊HTTPS</title>
    </head>
    <body>
        <!-- 输入文章类别： -->
        <article>
            <h1>聊聊HTTPS</h1>
            <p class="info">作者：石嘉</p>
            <p class="info">日期：2019年7月7日</p>
            <p class="info">参考：<a href="https://zhuanlan.zhihu.com/p/38278311">又拍云</a></p>
            <p class="info">参考：<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">阮一峰</a></p>
            <h2>SSL层</h2>
            <p>简而言之，HTTPS就是在HTTP下加入了SSL层，它有以下3个用途：</p>
            <ol>
                <li>通过证书信息确认网站的真实性；</li>
                <li>建立加密的信息通道；</li>
                <li>数据内容的完整性。</li>
            </ol>
            <h2>问题</h2>
            <p>网站的证书如何防止篡改？</p>
            <p>加密是使用的RSA算法吗？</p>
            <p>完整性是否通过哈希值验证？</p>
            <h2>如何实现</h2>
            <p>SSL协议的基本思路是采用公钥加密算法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>
            <p>但是，这里存在两个问题：</p>
            <ol>
                <li>如何保证公钥不被篡改？</li>
                <p>解决办法：将公钥放在数字证书中。</p>
                <li>公钥加密计算量太大，如何减少耗用时间？</li>
                <p>解决办法：每一对session，客户端和服务器都生成一个“对话秘钥”，用它来加密信息。由于“对话秘钥”是对称加密，所以运算速度很快，而服务器公钥只用于加密“对话秘钥”本身，这样就减少了加密运算的消耗时间。</p>
            </ol>
            <h2>握手阶段的详细过程</h2>
            <p>“握手阶段”涉及四次通信，所有通信都是明文的。</p>
            <h3>客户端发出请求</h3>
            <p>首先，客户端先向服务器发送加密通信的请求，这被叫做ClientHello请求。</p>
            <p>在这一步，客户端主要向服务器提供以下信息：</p>
            <ol>
                <li>支持的协议版本，如TSL 1.0版。</li>
                <li>一个客户端生成的随机数，稍后用于生成“对话秘钥”。</li>
                <li>支持的加密方法，比如RSA公钥加密。</li>
                <li>支持的压缩算法。</li>
            </ol>
            <h3>服务器响应</h3>
            <p>服务器收到客户端请求后，向客户端发出回应，这叫ServerHello。</p>
            <p>服务器的回应包含以下内容：</p>
            <ul>
                <li>确认使用的加密通信协议版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</li>
                <li>一个服务器生成的随机数，稍后用于生成“对话密钥”。</li>
                <li>确认使用的加密算法，如RSA公钥加密。</li>
                <li>服务器证书。</li>
            </ul>
            <h3>客户端回应</h3>
            <p>客户端收到服务器回应后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p>
            <p>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息：</p>
            <ol>
                <li>一个随机数。<b>该随机数用于服务器公钥加密，防止被窃听。</b></li>
                <li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li>
                <li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</li>
            </ol>
            <p>至于为什么需要3个随机数，是因为SSL协议不信任每个主机都能产生完全随机的随机数。每增加一个随机数，随机的概率就越大，被猜中的概率越小。</p>
            <h3>服务器最后回应</h3>
            <p>服务器收到客户端的第三个随机数之后，计算生成本次会话所用的“会话私钥”。然后，向客户端发送下面信息：</p>
            <ol>
                <li>编码改变通知，表示随后的信息都将用双方协定的加密方法和密钥发送。</li>
                <li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</li>
            </ol>
            <p>到了这里，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信后，就完全是普通的HTTP协议，只不过用“会话秘钥”加密内容。</p>
            <h2>总结</h2>
            <p>握手阶段主要是为了协商非对称加密算法以及生成对话密钥。</p>
            <p>其中：</p>
            <ul>
                <li>对话秘钥是对称算法，它对通信内容进行加密。</li>
                <li>非对称加密算法只对会话秘钥进行加密。</li>
            </ul>
            <p>所以整个SSL协议的核心在于通过四次握手把客户端加密的随机数（第3次握手）发送给服务器，然后HTTP消息用会话秘钥进行加密。</p>
            <p>前两次握手核心在于传递公钥和完整性校验，后两次握手在于传递加密随机数和完整性校验。</p>
            <p>（完）</p>
        </article>
        <script src="https://shijiatongxue.github.io/js/prism.js"></script>
    </body>
</html>