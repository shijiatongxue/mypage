<!DOCTYPE html>
<html lang="ch">
    <head>
        <link rel="icon" href="https://shijiatongxue.github.io/images/sj.png" type="image/png">
        <link rel="shortcut icon" href="https://shijiatongxue.github.io/images/sj.png" type="image/png">
        <link rel="stylesheet" href="https://shijiatongxue.github.io/styles/article.css">
        <title>作用域和闭包</title>
    </head>
    <body>
        <!-- 输入文章类别： -->
        <article>
            <h1>作用域和闭包</h1>
            <p class="info">作者：石嘉</p>
            <p class="info">日期：2019年7月10日</p>
            <p class="info">参考：你不知道的JavaScript</p>
            <h2>编译的过程</h2>
            <p>分三步：</p>
            <ul>
                <li>分词</li>
                <li>生成抽象语法树</li>
                <li>将语法树转化为可执行代码</li>
            </ul>
            <p>JavaScript的编译过程比上面较为复杂，它在后两个阶段进行优化。</p>
            <h2>作用域</h2>
            <p>作用域是一套规则，这套规则管理引擎如何在当前作用域以及嵌套子作用域中根据标识符名称进行变量查找。</p>
            <h3>与作用域有关的成员</h3>
            <ul>
                <li>引擎：负责整个JavaScript的编译和执行过程</li>
                <li>编译器：负责语法解析和代码生成</li>
                <li>作用域：用于确定当前代码对标识符的访问权限</li>
            </ul>
            <h3>赋值表达式</h3>
            <pre>
                <code class="lang-javascript">
                    var a = 2;
                </code>
            </pre>
            <p>编译器的处理过程：</p>
            <ul>
                <li>遇到var a，编译器会询问作用域是否存在同名变量。如果是，则忽略该声明；否则会在当前作用域集合中声明一个变量，并命名为a。 </li>
                <li>接下来编译器会生成引擎运行时所需要的代码，这些代码用来处理a = 2这个赋值操作。引擎会首先问当前作用域是否有变量a。如果是，引擎则使用这个变量；如果否，则会顺着<strong>作用域链</strong>继续查找。</li>
            </ul>
            <p>如果最终引擎找到了a变量，则会将2赋值给它。否则引擎会抛出错误。</p>
            <h3>引擎查找变量的模式</h3>
            <p>在上面的第二步中，引擎会在作用域进行LHS查找，另一种查找是RHS查找。</p>
            <ul>
                <li>LHS查找</li>
                <li>RHS查找</li>
            </ul>
            <p>RHS查找，可以理解为“取值”。如<code>console.log(a);</code>这里的a就是取出a的值。</p>
            <p>LHS查找，是赋值操作，如<code>a=2</code>。这时我们不关心a的值是多少。</p>
            <p>两者的区别：并不一定是在=的左右两侧，而是它们本身的意义的区别。</p>
            <h3>作用域的嵌套</h3>
            <p>当一个函数或块嵌套在另一个块或函数中，就发生了作用域的嵌套。在当前作用域没有找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量或抵达全局作用域为止。</p>
            <h3>为什么要区别LHS和RHS</h3>
            <p>引擎对于在两种情况下找不到的处理不同：</p>
            <ul>
                <li>RHS：在所有作用域都找不到，抛出ReferenceError异常；</li>
                <li>LHS：找不到，则自动在全局作用域创建变量（非严格模式）。</li>
            </ul>
            <p>在严格模式下，两者都会抛出ReferenceError异常。</p>
            <p>另外，如果RHS找到一个变量，但是你对该变量进行不合理的操作，如对非函数引用变量进行函数调用，或引用null和undefined类型值中的属性。那么，引擎会抛出TypeError。</p>
            <h2>词法作用域</h2>
            <p>作用域分为两种模型：</p>
            <ul>
                <li>词法作用域（大多数编程语言）</li>
                <li>动态作用域（Bash脚本、Perl中的一些模式）</li>
            </ul>
            <p>编译的第一个过程即叫分词，也叫词法化。</p>
            <p>简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里决定的，因此词法分析器处理代码时会保持作用域不变。</p>
            <h3>欺骗词法</h3>
            <p>有两种方式可以修改词法作用域：</p>
            <li>eval</li>
            <pre>
                <code class="lang-javascript">
                var foo = function(str, a){
                eval(str); // 欺骗
                console.log(a, b);
                }
                var b = 2;
                foo(&quot;var b = 3;&quot;, 1); // &gt;= 1,3
                </code>
            </pre>
            <li>with
            <p>with经常用于重复引用同一个对象多个属性的快捷方式。</p>
            <pre>
                <code class="lang-javascript">with(obj){
                a = 3; // 相当于obj.a = 3;
                b = 4;
                c = 5;
                }
                </code>
            </pre>
            <p>注意：在严格模式下，with被完全禁止，eval的使用也会受影响，因此，应该尽量少地是使用这两个关键词。
            <h3>性能</h3>
            <p>在使用eval和with的时候，很有可能会对编译优化造成巨大影响，从而降低程序运行效率。</p>
            <p>如果程序中有大量的eval和with，那么运行起来一定会特别慢。</p>
            <h3>eval()和with的区别</h3>
            <p>eval根据传入的代码段，在运行时修改原来的词法作用域；with直接新建一个全新的词法作用域。</p>
            <h2>函数作用域与块作用域</h2>
            <p>避免冲突的办法：</p>
            <ul>
                <li>全局命名空间：为每个库声明一个全局命名空间，属于库的属性和方法全部封装到这个全局对象内；</li>
                <li>模块管理：通过依赖管理器将库的标识符转移到一个特定的作用域中。</li>
            </ul>
            <h3>函数作用域</h3>
            <p>通过函数作用域可以将函数内部的变量和方法封装起来。</p>
            <p>缺点：</p>
            <ul>
            <li>必须声明一个具名函数，这个函数名会污染到全局作用域； </li>
            <li>其次，必须通过函数名调用函数才能运行其中的代码。</li>
            </ul>
            <p>解决方法：</p>
            <li>立即函数</li>
            <pre>
                <code class="lang-javascript">
                    (function foo(){
                    // 此处省略函数体
                    })();
                </code>
            </pre>
            <p>立即函数有两种形式：<code>(function(){})()</code>和<code>(function(){}())</code>，两者是等价的。</p>
            <li>匿名函数表达式</li>
            <pre>
                <code class="lang-javascript">
                    setTimeInterval(function(){}, 1000);
                </code>
            </pre>
            <p>但是匿名函数也有缺点：</p>
            <li>调用自身困难，需要借用arguments.callee引用；</li>
            <li>省略了函数名，可读性较差；</li>
            <li>由于没有函数名，导致在栈追踪时不会显示出有意义的名称，调试困难。
            <h3>块作用域</h3>
            <p>表面上看JavaScript没有块级作用域。</p>
            </ul>
            <p>例外：</p>
            <ul>
            <li>with</li>
            <li>try-catch：catch会创建块作用域</li>
            <li>let：let关键字定义的变量可以在{}作用域。<strong>ES6</strong></li>
            <li>const：const定义的常量只在块内有效</li>
            </ul>
            <h2>变量提升</h2>
            <p>作用域总结：任何声明在某一个作用域内的变量，都将附属于这个作用域。</p>
            <h3>提升的原理</h3>
            <p>在编译的第一个过程会找到所有声明，并用合适的作用域把它们关联起来。</p>
            <p>提升：变量和函数声明从定义位置移动到了最上面。</p>
            <p>值得注意的是：包括函数表达式在内的赋值操作并不会提升</strong>。</p>
            <h3>块级作用域的提升</h3>
            <p>一个普通块级作用域内的函数声明通常会被提升到作用域的顶部。</p>
            <pre>
                <code class="lang-javascript">
                    foo(); // &gt;= &quot;b&quot;

                    var a = true;

                    if (a){
                        function foo(){console.log(&quot;a&quot;);}
                    }
                    else{
                        function foo(){console.log(&quot;b&quot;);}
                    }
                </code>
            </pre>
            <h2>作用域闭包</h2>
            <p>闭包是基于词法作用域书写时产生的必然结果。</p>
            <h3>定义</h3>
            <p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域外执行。</p>
            <pre>
                <code class="lang-javascript">
                    function foo(){
                    var a = 2;
                    function bar(){
                        console.log(a);
                    }
                    return bar;
                    }
                    var baz = foo();
                    baz(); // &gt;= 2 , 这就是闭包的效果！
                </code>
            </pre>
            <h3>循环与闭包</h3>
            <p>奇怪的结果，并不是每隔一秒打印0-5！</p>
            <pre>
                <code class="lang-javascript">
                for(var i = 0; i&lt;=5; i++){
                setTimeout(function timer(){
                    console.log(i)
                }, 1000*i);
                }
                // &gt;= 6（6次）
                </code>
            </pre>
            <p>解决办法：</p>
            <li>通过立即函数创建每次迭代的函数作用域。</li>
            <pre>
                <code class="lang-javascript">
                    for(var i = 0; i&lt;=5; i++){
                    (function(j){
                        setTimeout(function timer(){
                            console.log(j)
                        }, 1000*j);    
                    })(i);
                    }
                </code>
            </pre>
            <li>通过let关键字</li>
            <pre>
                <code class="lang-javascript">
                    for(var i = 0; i&lt;=5; i++){
                    let j = i;
                    setTimeout(function timer(){
                        console.log(j)
                    }, 1000*j);    
                    }
                </code>
            </pre>
            <p>（完）</p>
        </article>
        <script src="https://shijiatongxue.github.io/js/prism.js"></script>
    </body>
</html>